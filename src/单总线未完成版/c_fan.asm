#include <head.inc>
//延时表：DELAY2US，DELAY10US，DELAY25US，DELAY60US，DELAY80US，DELAY600US，DELAY10MS，DELAY800MS，DELAY1000MS
ORG 0000H     							//复位地址
AJMP MAIN     							//绝对短跳转至主程序
ORG 0003H	  							//外中断0入口地址
AJMP KEY_0     							//绝对跳转至外中断0子程序
ORG 0100H     							//主程序地址分配
								/************************
									主程序
								************************/
MAIN:	   	  
ACALL INIT  							//初始化
M_LOOP:
MOV IE, #00H							//关闭所有中断
ACALL READ_T_DO
ACALL DRIVE_LED_C
MOV IE, #81H							//仅开启外中断0
MOV PCON, #02H							//进入掉电模式
NOP
NOP
JB LSE,$
AJMP M_LOOP
								/************************
									初始化子程序
								************************/
INIT:
MOV SP,#7FH								//堆栈指针设置
CLR LSE									//清零温差设置模式标志
MOV IAP_ADDRH, #00H						//E2PROM的IAP操作地址高位
MOV IAP_ADDRL, #00H						//E2PROM的IAP操作地址低位
ACALL R_E2PROM							//装载E2PROM中上次设置的温差限设置至A
MOV TPDF_COPY,A
SETB P3.2								//键盘初始化
ACALL KCLR
SETB TCON.0								//设置外中断0仅下降沿产生中断
MOV IE, #00H							//关闭所有中断
ACALL RS_18B20							//18B20初始化
MOV A, #0CCH							//跳过ROM(ROM指令)
ACALL W_18B20_BYTE
MOV A, #4EH								//写暂存器(功能指令)
ACALL W_18B20_BYTE
MOV A, #55H								//高温报警限
ACALL W_18B20_BYTE
MOV A, #0F5H							//低温报警限
ACALL W_18B20_BYTE
MOV A, #1FH								//配置9位精度
ACALL W_18B20_BYTE
ACALL RS_18B20							//18B20初始化
MOV A, #0CCH							//跳过ROM(ROM指令)
ACALL W_18B20_BYTE
MOV A, #48H								//拷贝暂存器(功能指令)
ACALL W_18B20_BYTE
MOV WKTCL, #0FFH						//送入掉电唤醒时钟计数低八位
MOV WKTCH, #9FH							//送入掉电唤醒时钟计数高七位，并打开掉电唤醒时钟
RET
								/*************************
									判断温差，执行驱动
								*************************/
READ_T_DO:
MOV IE, #00H							//关闭键盘的外部中断
ACALL RS_18B20
MOV A, #0CCH							//忽略ROM
ACALL W_18B20_BYTE
MOV A, #44H								//启动温度转换
ACALL W_18B20_BYTE
ACALL DELAY1000MS
ACALL RS_18B20
ACALL MATCH_ROM1						//匹配ROM1
MOV A, #0BEH							//读暂存器
ACALL W_18B20_BYTE
ACALL R_18B20_BYTE
MOV TPT1_L,A
ACALL R_18B20_BYTE
MOV TPT1_H,A
ACALL RS_18B20
ACALL MATCH_ROM2						//匹配ROM2
MOV A, #0BEH							//读暂存器
ACALL W_18B20_BYTE
ACALL R_18B20_BYTE
MOV TPT2_L,A
ACALL R_18B20_BYTE
MOV TPT2_H,A
ACALL CCLAT
MOV A,TPDF_COPY
CJNE A,TPDF_C,J_DO
J_DO:
JC DO
DEC A
DEC A
CJNE A,TPDF_C,J_UNDO
J_UNDO:
JNC UNDO
MOV IE, #81H							//温差在温差限之间，无动作返回，重新开启键盘中断
RET
DO:
SETB EXECT								//温差高于温差上限，动作
MOV IE, #81H							//开启键盘中断
RET
UNDO:
CLR EXECT								//温差低于温差下限，停止动作
MOV IE, #81H							//开启键盘中断
RET
CCLAT:									//温度计算转换成两位BCD码：TPDF_C_H，TPDF_C_L。
MOV A,TPT1_L
ACALL CCLAT_MOV_R
MOV TPT1_L,A
MOV A,TPT1_H
ACALL CCLAT_MOV_L
MOV TPT1_H,A
ORL A,TPT1_L
MOV TEMP1,A
MOV A,TPT2_L
ACALL CCLAT_MOV_R
MOV TPT2_L,A
MOV A,TPT2_H
ACALL CCLAT_MOV_L
MOV TPT2_H,A
ORL A,TPT2_L
MOV TEMP2,A
SUBB A,TEMP1							//影响最终温差的正负，可调换以调整
RLC A
JC CCLAT_N
CLR CCLATNF
RRC A
MOV TPDF_C,A
MOV B, #64H
DIV AB
MOV A,B
MOV B, #0AH
DIV AB
MOV TPDF_C_H,A
MOV TPDF_C_L,B
RET
CCLAT_N:
SETB CCLATNF
CPL A
RRC A
ANL A, #7FH
INC A
MOV TPDF_C,A
MOV B, #64H
DIV AB
MOV A,B
MOV B, #0AH
DIV AB
MOV TPDF_C_H,A
MOV TPDF_C_L,B
RET
CCLAT_MOV_R:
ANL A, #0F0H
RR A
RR A
RR A
RR A
RET
CCLAT_MOV_L:
ANL A, #0FH
RL A
RL A
RL A
RL A
RET
								/*************************
								依据计算温差，驱动数码管
								*************************/
DRIVE_LED_C:
JB CCLATNF,DRV_N						//计算温差为负跳转
MOV LEDN1, #0FFH						//第一个数码管不亮(计算温差为正时)
MOV DPTR,#LEDNUM
MOV A,TPDF_C_H
MOVC A,@A+DPTR
MOV LEDN2,A
MOV A,TPDF_C_L
MOVC A,@A+DPTR
MOV LEDN3,A
ACALL W_Latch
RET
DRV_N:
MOV LEDN1, #7FH						//第一个数码管显示负号
MOV DPTR,#LEDNUM
MOV A,TPDF_C_H
MOVC A,@A+DPTR
MOV LEDN2,A
MOV A,TPDF_C_L
MOVC A,@A+DPTR
MOV LEDN3,A
ACALL W_Latch
RET
								/*************************
								依据键盘按键，驱动数码管
								*************************/
DRIVE_LED_KEY:							//按0号按键(设置键)，数码管显示
JNB LSE,USELESS
MOV LEDN1, #57H						//第一个数码管显示设置符号
ACALL CCLAT_TPDF						//转换设置温差为BCD
MOV DPTR,#LEDNUM
MOV A,TPDF_COPY_H
MOVC A,@A+DPTR
MOV LEDN2,A
MOV A,TPDF_COPY_L
MOVC A,@A+DPTR
MOV LEDN3,A
ACALL W_Latch							//写入锁存器
RET
USELESS:
ACALL DRIVE_LED_C						//驱动数码管显示计算温差
RET
CCLAT_TPDF:								//转TPDF_COPY为BCD，并存入TPDF_COPY_L,TPDF_COPY_H
MOV A, TPDF_COPY
MOV B, #64H
DIV AB
MOV A,B
MOV B, #0AH
DIV AB
MOV TPDF_COPY_H,A
MOV TPDF_COPY_L,B
RET
				/*写锁存器(3Byte)*/
W_Latch:								//将LEDN1,LEDN2,LEDN3内容顺次由高位到低位串行写入三个锁存器
CLR OE
CLR SCK
CLR LCK
MOV ACC,LEDN3
MOV W_LAT,#08H
ACALL W_L_LOOP
MOV ACC,LEDN2
MOV W_LAT,#08H
ACALL W_L_LOOP
MOV ACC,LEDN1
MOV W_LAT,#08H
ACALL W_L_LOOP
SETB SCK
CLR SCK
RET
W_L_LOOP:
RLC A
MOV SDI,C
SETB LCK
CLR LCK
DJNZ W_LAT,W_L_LOOP
RET
				/*数码管数据表*/
LEDNUM:
DB 82H,0FAH,46H,52H,3AH,13H,03H,0DAH,02H,12H,57H,0AH,22H,7FH
//  0,  1,   2,  3,  4,  5, 6,  7,  8,  9, 设置,气温,水温,负号
								/*************************
									DS18B20
								*************************/
RS_18B20:		/*18B20复位时序*/				
ACALL DELAY600US
SETB DQ
NOP
NOP
CLR DQ
ACALL DELAY600US
SETB DQ
ACALL DELAY80US
JB DQ, RS_18B20
ACALL DELAY600US
RET
W_18B20_BYTE:	/*写18B20一个字节*/		
SETB DQ
MOV R5, #08H
W_18B20_BIT:
RRC A
CLR DQ
ACALL DELAY2US
MOV DQ, C
ACALL DELAY25US
SETB DQ
ACALL DELAY60US
DJNZ R5, W_18B20_BIT
RET
R_18B20_BYTE:	/*读18B20一个字节*/		
SETB DQ
MOV R5, #08H
R_18B20_BIT:
CLR DQ
ACALL DELAY2US
SETB DQ
ACALL DELAY10US
MOV C, DQ
ACALL DELAY60US
RRC A
DJNZ R5, R_18B20_BIT
RET
				/*18B20ROM一字位写入C*/
SEARCH_LOOP:							//两读一写
ACALL R_18B20_BIT
MOV ROMR1,C
ACALL R_18B20_BIT
MOV ROMR2,C
JG_ROMR:
JNB ROMR1,JG_0
JB ROMR1,JG_1
JG_0:
JNB ROMR2,S_R_00
JB ROMR2,S_R_01
JG_1:
JNB ROMR2,S_R_10
JB ROMR2,S_R_11
S_R_01:									//两读为01则表明所有ROM这一位均为0
CLR C
ACALL W_18B20_BIT
RET
S_R_10:									//两读为10则表明所有ROM这一位均为1
SETB C
ACALL W_18B20_BIT
RET
S_R_11:									//两读为11则表明没有ROM响应
MOV IAP_CONTR, #20H						//进行软件复位
S_R_00:									//两读为00则表明ROM在此位数据冲突
MOV ROMJ,ROMPTR
JB ROMJE,S_R_00_1
SETB ROMJF
CLR C
ACALL W_18B20_BIT
RET
S_R_00_1:
CLR ROMJE
CLR ROMJF
SETB C
ACALL W_18B20_BIT
RET
				/*18B20ROM写入RAM循环*/
S_W_LOOP:								//循环写入64位ROM到ROMPTR指定地址
ACALL SEARCH_LOOP
RRC A
DJNZ R5,S_W_LOOP
MOV R5, #08H
MOV R1,ROMPTR							//此处问题，R3编译通不过(原来寄存器间接寻址仅能使用R0,R1)
MOV @R1,A			
INC ROMPTR
DJNZ R4,S_W_LOOP
RET
				/*18B20ROM搜索并写入RAM主程序*/
SEARCH_ROM:
MOV ROMPTR, #40H
ACALL RS_18B20							//18B20复位
MOV A, #0F0H							//写入搜索ROM指令
ACALL W_18B20_BYTE
SETB DQ
MOV R4, #08H
ACALL S_W_LOOP							//写入ROM1
MOV C,ROMJF
MOV ROMJE,C
ACALL RS_18B20							//18B20复位
MOV A, #0F0H							//第二次写入搜索ROM指令
ACALL W_18B20_BYTE
SETB DQ
MOV R4, #08H
ACALL S_W_LOOP							//写入ROM2
RET
				/*18B20ROM匹配主程序*/
MATCH_ROM1:								//匹配ROM1
ACALL RS_18B20							//复位
MOV A, #55H								//匹配ROM
ACALL W_18B20_BYTE
SETB DQ
MOV ROMPTR, #40H						//ROM1首地址送入指针
MOV R4, #08H
ACALL M_R_LOOP
RET
MATCH_ROM2:								//匹配ROM2
ACALL RS_18B20							//复位
MOV A, #55H								//匹配ROM
ACALL W_18B20_BYTE
SETB DQ
MOV ROMPTR, #48H						//ROM2首地址送入指针
MOV R4, #08H
ACALL M_R_LOOP
RET
M_R_LOOP:								//匹配数据写入循环
MOV R1,ROMPTR
MOV A,@R1
ACALL W_18B20_BYTE
INC ROMPTR
DJNZ R4,M_R_LOOP
RET
								/************************
									按键判断
								************************/
KEY_0:				/*0号按键判断(设定)*/
CLR K0
SETB K1
SETB K2
NOP
NOP
JB P3.2,KEY_1
ACALL DELAY10MS						//软件去抖，调用延时子程序，延时大约10ms
JNB P3.2,KEY0		    			//判断P3.2低电平跳转（0键确实按下）
ACALL KCLR
RETI
KEY0:				
ACALL DELAY10MS						//松手去抖，调用延时子程序，延时大约10ms
JB P3.2,KEY00							//判断P3.2高电平跳转（确实松手）
AJMP KEY0		    				//判断P3.2低电平跳转（循环检测松手高电平）  
KEY00:
CPL LSE
ACALL DRIVE_LED_KEY
ACALL KCLR
RETI
KEY_1:	           	/*1号按键判断(数字加)*/ 
SETB K0
CLR K1
SETB K2
NOP
NOP
JB P3.2,KEY_2
ACALL DELAY10MS						//软件去抖，调用延时子程序，延时大约10ms
JNB P3.2,KEY1		    			//判断P3.2低电平跳转（1键确实按下）
ACALL KCLR
RETI
KEY1:
ACALL DELAY10MS						//松手去抖，调用延时子程序，延时大约10ms
JB P3.2,KEY10							//判断P3.2高电平跳转（确实松手）
AJMP KEY1							//判断P3.2低电平跳转（循环检测松手高电平）  
KEY10:
JB LSE,KEY100
ACALL KCLR
RETI
KEY100:
MOV A,TPDF_COPY
CJNE A, #63H,JUDGE_T						//与99度温差比较
ACALL KCLR
RETI
KEY_2:	           	/*2号按键判断(数字减)*/ 
SETB K1
CLR K2
SETB K0
NOP
NOP
ACALL DELAY10MS						//软件去抖，调用延时子程序，延时大约10ms
JNB P3.2,KEY2		    			//判断P3.2低电平跳转（2键确实按下）
ACALL KCLR
RETI
KEY2:	          	/*2号按键判断(数字减)*/     					
ACALL DELAY10MS						//松手去抖，调用延时子程序，延时大约10ms
JB P3.2,KEY20							//判断P3.2高电平跳转（确实松手）
AJMP KEY2		    				//判断P3.2低电平跳转（循环检测松手高电平）  
KEY20:
JB LSE,KEY200
ACALL KCLR
RETI
KEY200:
MOV A,TPDF_COPY
CJNE A, #03H,JUDGE_B						//与3度温差比较
ACALL KCLR
RETI
JUDGE_T:
JNC JUDGE_99
INC A
AJMP COPY
JUDGE_B:
JC JUDGE_03
DEC A
AJMP COPY
JUDGE_99:
MOV A,#63H
AJMP COPY
JUDGE_03:
MOV A,#03H
COPY:
ACALL E_E2PROM
MOV TPDF_COPY,A
ACALL W_E2PROM
MOV A,TPDF_COPY
ACALL DRIVE_LED_KEY
ACALL KCLR
RETI
KCLR:
CLR K0
CLR K1
CLR K2
RET
								/*************************
								延时函数集合
								*************************/
DELAY2US:			;@11.0592MHz
	NOP
	PUSH 30H
	MOV 30H,#1
NEXT2US:
	DJNZ 30H,NEXT2US
	POP 30H
	RET
DELAY10US:			;@11.0592MHz
	PUSH 30H
	MOV 30H,#19
NEXT10US:
	DJNZ 30H,NEXT10US
	POP 30H
	RET
DELAY25US:			;@11.0592MHz
	PUSH 30H
	MOV 30H,#52
NEXT25US:
	DJNZ 30H,NEXT25US
	POP 30H
	RET
DELAY60US:			;@11.0592MHz
	NOP
	NOP
	NOP
	PUSH 30H
	MOV 30H,#129
NEXT60US:
	DJNZ 30H,NEXT60US
	POP 30H
	RET
DELAY80US:			;@11.0592MHz
	NOP
	NOP
	NOP
	NOP
	PUSH 30H
	MOV 30H,#173
NEXT80US:
	DJNZ 30H,NEXT80US
	POP 30H
	RET
DELAY600US:			;@11.0592MHz
	NOP
	NOP
	PUSH 30H
	PUSH 31H
	MOV 30H,#6
	MOV 31H,#36
NEXT600US:
	DJNZ 31H,NEXT600US
	DJNZ 30H,NEXT600US
	POP 31H
	POP 30H
	RET
DELAY10MS:			;@11.0592MHz
	NOP
	NOP
	NOP
	PUSH 30H
	PUSH 31H
	MOV 30H,#87
	MOV 31H,#10
NEXT10MS:
	DJNZ 31H,NEXT10MS
	DJNZ 30H,NEXT10MS
	POP 31H
	POP 30H
	RET

DELAY800MS:			;@11.0592MHz
	NOP
	NOP
	NOP
	PUSH 30H
	PUSH 31H
	PUSH 32H
	MOV 30H,#27
	MOV 31H,#229
	MOV 32H,#249
NEXT800MS:
	DJNZ 32H,NEXT800MS
	DJNZ 31H,NEXT800MS
	DJNZ 30H,NEXT800MS
	POP 32H
	POP 31H
	POP 30H
	RET
DELAY1000MS:			;@11.0592MHz
	NOP
	NOP
	NOP
	PUSH 30H
	PUSH 31H
	PUSH 32H
	MOV 30H,#34
	MOV 31H,#159
	MOV 32H,#56
NEXT1000MS:
	DJNZ 32H,NEXT1000MS
	DJNZ 31H,NEXT1000MS
	DJNZ 30H,NEXT1000MS
	POP 32H
	POP 31H
	POP 30H
	RET
								/************************
									EEPROM读写(1BYTE)
								************************/
R_E2PROM:								//读取E2PROM数据到A
MOV IAP_ADDRH, #00H
MOV IAP_ADDRL, #00H
MOV IAP_CONTR, #10000011B
MOV IAP_CMD, #01H
MOV IAP_TRIG, #5AH
MOV IAP_TRIG, #0A5H
NOP
MOV A,IAP_DATA
RET
E_E2PROM:								//擦除E2PROM一个扇区数据
MOV IAP_ADDRH, #00H
MOV IAP_ADDRL, #00H
MOV IAP_CONTR, #10000011B
MOV IAP_CMD, #03H
MOV IAP_TRIG, #5AH
MOV IAP_TRIG, #0A5H
NOP
RET
W_E2PROM:								//写入A中数据到E2PROM
MOV IAP_DATA, A
MOV IAP_ADDRH, #00H
MOV IAP_ADDRL, #00H
MOV IAP_CONTR, #10000011B
MOV IAP_CMD, #02H
MOV IAP_TRIG, #5AH
MOV IAP_TRIG, #0A5H
NOP
RET
END
